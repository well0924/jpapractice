# 에러 일지

### 만드는 과정에서 마주친 에러와 배워야 할 부분

1일차


페이징 타임리프 에러
${T(Math).floor(totalPages / pageSize) * pageSize - 1 <= startPage}

->Math를 인식을 하지 못해서 생긴 문제

해결
->java.lang.Math로 자바 라이브러리명을 제대로 입력을 한 뒤 작동



2일차


게시판 글 수정시 조회수가 등록이 되지 않은 경우

<pre>
<code>
@Transactional
	public Integer updateBoard(Integer boardId, BoardRequestDto dto)throws Exception{
		
		Optional<Board>articlelist = Optional.ofNullable(repos.findById(boardId).orElseThrow(()-> new IllegalArgumentException("해당 게시글이 없습니다.")));
				
		articlelist.ifPresent(t->{
			
			if(dto.getBoardTitle() != null) {
				t.setBoardTitle(dto.getBoardTitle());
			}
			if(dto.getBoardAuthor() != null) {
				t.setBoardAuthor(dto.getBoardAuthor());
			}
			if(dto.getBoardContents() != null) {
				t.setBoardContents(dto.getBoardContents());
			}
			if(dto.getReadCount() !=null) {
				t.setReadCount(dto.getReadCount());
			}
			if(dto.getCreatedAt() != null) {
				t.setCreatedAt(dto.getCreatedAt());
			}
			
			this.repos.save(t);
		});
		
		return boardId;
	}
	
</code>
</pre>

- optional로 객체의 정보를 추출한 뒤 데이터 개별로 값을 정해야 한다는 점


- 추출하는 방법은 ifPresent를 활용해서 if문을 활용해서 데이터의 값을 수정한다.



3일차

- 댓글의 내용을 조회하는 과정에서 특정 게시물에 등록한 댓글이 다른 게시글에서도 나오게 된 문제

- service부분에서 기본적인 findById로 하다가 안되었고 검색을 하던 도중에서 jpql을 알게 되어서 적용을 했다.

<pre>
<code>
	@Query("select c from Comment c where c.board.id = :id")
	List<Comment>findCommentsBoardId(@Param("id") Integer id)throws Exception;
</code>
</pre>


- 추후에 jpql에 관련된 내용을 공부할 예정임.


5일차

- 댓글 작성 및 삭제 기능구현 완료

- 엔티티간의 조인을 하는데 있어서 연관관계를 공부

<pre>
<code>
@Setter
@Getter
@Entity
@Builder
@Table(name="board")
@AllArgsConstructor
@RequiredArgsConstructor
public class Board extends BaseTime{
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name="board_id")
	private Integer boardId;
	
	@Column(name = "board_title",nullable = false)
	@NotBlank(message="게시글 제목을 입력해주세요.")
	private String boardTitle;
	
	@Column(name = "board_contents",nullable = false)
	@NotBlank(message = "게시글 내용을 입력해주세요.")
	private String boardContents;
	
	@Column(name = "board_author",nullable = false)
	@NotBlank(message = "게시글 작성자를 입력해주세요.")
	private String boardAuthor;
	
	@Column(name = "read_count",nullable = true)
	private Integer readCount;
	
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm")
	private LocalDateTime createdAt;
	
	@JsonIgnore
	@OneToMany(mappedBy = "board", fetch = FetchType.LAZY)
	private List<Comment>commentlist;
}	
</code>
</pre>

- 해당 코드에서 @OneToMany는 1대다로 게시글 하나에 댓글 여러개를 작성하기 위해서 선언

- mappedBy는 Comment엔티티의 어떤 필드와 매칭이 되는지를 지정.

- fetch전략은 게시글이 나왔을때 나오게끔 lazy로 선언.

<pre>
<code>
@Entity
@Getter
@Builder
@Table(name="reply")
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = "board")
public class Comment extends BaseTime{
	
	@Id
	@Column(name="reply_id")
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer replyId;
		
	@Column(name="reply_writer",nullable = false)
	private String replyWriter;
	
	@Column(name="reply_contents", nullable = false)
	private String replyContents;
	
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm")
	private LocalDateTime createdAt;
	
	@JsonIgnore
	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name="board_id")
	private Board board;
	
}
</code>
</pre>

- @ManyToOne에서는 다 대 일 관계

- 하나의 게시글에 여러개의 댓글을 가지고 있기 때문에 댓글의 관점에서는 @ManyToOne으로 정합니다.

- @JoinColum은 외래키의 이름을 정할 때 사용한다.(Board테이블의 board_id 를 fk로 정하는 것을 말한다.)


6일차

- 회원가입시 유효성처리를 하기 위해서 validation을 사용.

<pre>
<code>
@Getter
	@Setter
	@ToString
	@Builder
	@NoArgsConstructor
	@AllArgsConstructor
	public static class MemberRequestDto{
		
		private Integer useridx;
		
		@NotBlank(message = "아이디는 필수 입력값입니다.")
		@Pattern(regexp = "^[a-z0-9]{4,20}$", message = "아이디는 영어 소문자와 숫자만 사용하여 4~20자리여야 합니다.")
		private String userid;
		
		@Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)(?=.*[$@$!%*#?&])[A-Za-z\\d$@$!%*#?&]{8,16}$", message = "비밀번호는 8~16자리수여야 합니다. 영문 대소문자, 숫자, 특수문자를 1개 이상 포함해야 합니다.")
		private String password;
		
		@NotBlank(message="회원이름을 입력해주세요.")
		@Pattern(regexp = "^[가-힣a-zA-Z0-9]{2,10}$" , message = "닉네임은 특수문자를 포함하지 않은 2~10자리여야 합니다.")
		private String membername;
		
		@NotBlank(message="이메일을 입력해주세요.")
		@Email
		private String useremail;
		
		private Role role;
		
		@JsonFormat(pattern = "yyyy-mm-dd HH:mm")
		private LocalDateTime createdAt;
		
	}
</code>
</pre>

- @NotBlanck : null이 아닌 값이고 공백이 아닌 무자를 하나 이상 포함한다.

- @NotEmpty : null이거나 empty가 아니어야 한다.

- @NotNull : null이 아닌 값.

- @Null : 어떤 타입이든 수용한다./null값이다.

- @Email : 올바른 형식의 이메일 주소인지 검증한다.(@가 들어가야 한다.)

- @Pattern : 지정한 정규식과 대응되는 문자열 이어야 한다. Java의 Pattern 패키지의 컨벤션을 따른다
      
  Require : String regexp  => 정규식 문자열을 지정한다
  

-   