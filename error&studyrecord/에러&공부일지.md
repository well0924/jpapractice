# 에러 일지

### 만드는 과정에서 마주친 에러와 배워야 할 부분

1일차


페이징 타임리프 에러
${T(Math).floor(totalPages / pageSize) * pageSize - 1 <= startPage}

->Math를 인식을 하지 못해서 생긴 문제

해결
->java.lang.Math로 자바 라이브러리명을 제대로 입력을 한 뒤 작동



2일차


게시판 글 수정시 조회수가 등록이 되지 않은 경우

<pre>
<code>
@Transactional
	public Integer updateBoard(Integer boardId, BoardRequestDto dto)throws Exception{
		
		Optional<Board>articlelist = Optional.ofNullable(repos.findById(boardId).orElseThrow(()-> new IllegalArgumentException("해당 게시글이 없습니다.")));
				
		articlelist.ifPresent(t->{
			
			if(dto.getBoardTitle() != null) {
				t.setBoardTitle(dto.getBoardTitle());
			}
			if(dto.getBoardAuthor() != null) {
				t.setBoardAuthor(dto.getBoardAuthor());
			}
			if(dto.getBoardContents() != null) {
				t.setBoardContents(dto.getBoardContents());
			}
			if(dto.getReadCount() !=null) {
				t.setReadCount(dto.getReadCount());
			}
			if(dto.getCreatedAt() != null) {
				t.setCreatedAt(dto.getCreatedAt());
			}
			
			this.repos.save(t);
		});
		
		return boardId;
	}
	
</code>
</pre>

- optional로 객체의 정보를 추출한 뒤 데이터 개별로 값을 정해야 한다는 점


- 추출하는 방법은 ifPresent를 활용해서 if문을 활용해서 데이터의 값을 수정한다.



3일차

- 댓글의 내용을 조회하는 과정에서 특정 게시물에 등록한 댓글이 다른 게시글에서도 나오게 된 문제

- service부분에서 기본적인 findById로 하다가 안되었고 검색을 하던 도중에서 jpql을 알게 되어서 적용을 했다.

<pre>
<code>
	@Query("select c from Comment c where c.board.id = :id")
	List<Comment>findCommentsBoardId(@Param("id") Integer id)throws Exception;
</code>
</pre>


- 추후에 jpql에 관련된 내용을 공부할 예정임.


5일차

- 댓글 작성 및 삭제 기능구현 완료

- 엔티티간의 조인을 하는데 있어서 연관관계를 공부

<pre>
<code>
@Setter
@Getter
@Entity
@Builder
@Table(name="board")
@AllArgsConstructor
@RequiredArgsConstructor
public class Board extends BaseTime{
	
	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name="board_id")
	private Integer boardId;
	
	@Column(name = "board_title",nullable = false)
	@NotBlank(message="게시글 제목을 입력해주세요.")
	private String boardTitle;
	
	@Column(name = "board_contents",nullable = false)
	@NotBlank(message = "게시글 내용을 입력해주세요.")
	private String boardContents;
	
	@Column(name = "board_author",nullable = false)
	@NotBlank(message = "게시글 작성자를 입력해주세요.")
	private String boardAuthor;
	
	@Column(name = "read_count",nullable = true)
	private Integer readCount;
	
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm")
	private LocalDateTime createdAt;
	
	@JsonIgnore
	@OneToMany(mappedBy = "board", fetch = FetchType.LAZY)
	private List<Comment>commentlist;
}	
</code>
</pre>

- 해당 코드에서 @OneToMany는 1대다로 게시글 하나에 댓글 여러개를 작성하기 위해서 선언

- mappedBy는 Comment엔티티의 어떤 필드와 매칭이 되는지를 지정.

- fetch전략은 게시글이 나왔을때 나오게끔 lazy로 선언.

<pre>
<code>
@Entity
@Getter
@Builder
@Table(name="reply")
@NoArgsConstructor
@AllArgsConstructor
@ToString(exclude = "board")
public class Comment extends BaseTime{
	
	@Id
	@Column(name="reply_id")
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	private Integer replyId;
		
	@Column(name="reply_writer",nullable = false)
	private String replyWriter;
	
	@Column(name="reply_contents", nullable = false)
	private String replyContents;
	
	@JsonFormat(pattern = "yyyy-MM-dd HH:mm")
	private LocalDateTime createdAt;
	
	@JsonIgnore
	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name="board_id")
	private Board board;
	
}
</code>
</pre>

- @ManyToOne에서는 다 대 일 관계

- 하나의 게시글에 여러개의 댓글을 가지고 있기 때문에 댓글의 관점에서는 @ManyToOne으로 정합니다.

- @JoinColum은 외래키의 이름을 정할 때 사용한다.(Board테이블의 board_id 를 fk로 정하는 것을 말한다.)
